export declare type CellValue = number | string | boolean | null | [string, ...any[]];
export interface IRecord {
    [colId: string]: CellValue;
}
export interface ITableData {
    [colId: string]: CellValue[];
}
export interface IFilterSpec {
    [colId: string]: CellValue[];
}
export declare function getAPIKey(): Promise<string>;
export interface IGristCallConfig {
    apiKey?: string;
    server?: string;
    dryrun?: boolean;
    chunkSize?: number;
}
/**
 * Class for interacting with a Grist document.
 */
export declare class GristDocAPI {
    private _dryrun;
    private _docId;
    private _server;
    private _apiKey;
    private _chunkSize;
    /**
     * Create a GristDocAPI object. You may specify either a doc URL, or just the doc ID (the part
     * of the URL after "/doc/"). If you specify a URL, then options.server is unneeded and ignored.
     *
     * See documentation of IGristCallConfig for options.
     */
    constructor(docUrlOrId: string, options?: IGristCallConfig);
    /**
     * Returns the docId identifying the document in API calls.
     */
    get docId(): string;
    /**
     * Fetch all data in the table by the given name, returning a list of records with attributes
     * corresponding to the columns in that table.
     *
     * If filters is given, it should be a dictionary mapping column names to values, to fetch only
     * records that match.
     */
    fetchTable(tableName: string, filters?: IFilterSpec): Promise<IRecord[]>;
    /**
     * Adds new records to the given table. The data is a list of dictionaries, with keys
     * corresponding to the columns in the table. Returns a list of added rowIds.
     */
    addRecords(tableName: string, records: IRecord[]): Promise<number[]>;
    /**
     * Deletes records from the given table. The data is a list of record IDs.
     */
    deleteRecords(tableName: string, recordIds: number[]): Promise<void>;
    /**
     * Update existing records in the given table. The data is a list of objects, with attributes
     * corresponding to the columns in the table. Each record must contain the key "id" with the
     * rowId of the row to update.
     *
     * If records aren't all for the same set of columns, then a single-call update is impossible,
     * so we'll make multiple calls.
     */
    updateRecords(tableName: string, records: IRecord[]): Promise<void>;
    /**
     * Updates Grist table with new data, updating existing rows or adding new ones, matching rows on
     * the given key columns. (This method does not remove rows from Grist.)
     *
     * New data is a list of objects with column IDs as attributes.
     *
     * keyColIds parameter lists primary-key columns, which must be present in the given records.
     *
     * If filters is given, it should be a dictionary mapping colIds to values, where colIds must be
     * included among keyColIds. Only existing records matching these filters will be matched as
     * candidates for rows to update. New records which don't match filters will be ignored too.
     */
    syncTable(tableName: string, records: IRecord[], keyColIds: string[], options?: {
        filters?: IFilterSpec;
    }): Promise<void>;
    attach(files: File[]): Promise<number[]>;
    /**
     * Low-level interface to make a REST call.
     */
    private _docCall;
    private _call;
}
